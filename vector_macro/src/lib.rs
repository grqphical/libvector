use proc_macro::TokenStream;
use quote::{format_ident, quote, ToTokens};
use syn;

fn letter_by_index(index: i32) -> char {
    if index > 25 {
        panic!("Above maximum length of Vector. Vector must be at most 26 fields")
    }

    let letter = char::from_u32(index as u32 + 97).unwrap(); // 97 is the ASCII value for 'a'
    letter
}

/// Generates a custom Vector struct based on the given length.
///
/// This can be used instead of `DynamicVector` to get custom length Vector objects. The advantage
/// of using this macro over `DynamicVector` is that all operations done with the struct generated by this macro are **O(1)**. If you were to use
/// `DynamicVector`, all of the operations would be in **O(n)** due to the use of a `Vec` within the `DynamicVector` struct.
///
/// **Note:** Due to the limitations of the macro, the maximum Vector length is 26. I may fix this is a future release however for now if
/// you need <26 length Vectors, use `DynamicVector`
///
/// ## Naming Convention
///
/// The struct generated will be called Vector + the length given. So `vector!(5)` will create a struct called Vector5
///
/// ## Examples
///
/// ```
/// // Import both the macro and the shared Vector trait
/// use libvector::{vector, Vector}
///
/// // Generates a Vector with 4 fields called `Vector5`
/// vector!(5);
/// ```
#[proc_macro]
pub fn vector_macro(input: TokenStream) -> TokenStream {
    let input = proc_macro2::TokenStream::from(input);
    let literal: syn::LitInt = syn::parse2(input).unwrap();
    let length: i32 = literal.base10_parse().unwrap();
    let mut fields = quote! {};
    let mut args = quote! {};
    let mut initalizers = quote! {};

    let mut dot_product_statement = quote! {};
    let mut magnitude_statement = quote! {let magnitude_square = };
    let mut normalize_statements = quote! {};

    for i in 0..length {
        let name = format_ident!("{}", letter_by_index(i));
        let field = quote! {
            pub #name: f64,
        };
        field.to_tokens(&mut fields);
        let arg = quote! {
            #name: f64,
        };
        arg.to_tokens(&mut args);
        let initalizer = quote! {
            #name: #name,
        };
        initalizer.to_tokens(&mut initalizers);
        let dot_product_iteration = quote! {
            self.#name * other.#name +
        };
        dot_product_iteration.to_tokens(&mut dot_product_statement);
        let magnitude_iteration = quote! {
            self.#name * self.#name +
        };
        magnitude_iteration.to_tokens(&mut magnitude_statement);
        let normalize_iteration = quote! {
            #name: self.#name / mag,
        };
        normalize_iteration.to_tokens(&mut normalize_statements);
    }

    if length == 1 {
        panic!("Vector length must be greater than one")
    }

    //  Add a zero at the end to prevent a syntax error
    quote! {0.}.to_tokens(&mut dot_product_statement);
    quote! {0.}.to_tokens(&mut magnitude_statement);

    quote! {; magnitude_square.sqrt()}.to_tokens(&mut magnitude_statement);

    let normalize_func = quote! {
        let mag = self.magnitude();
        Self {
            #normalize_statements
        }
    };

    let title = format_ident!("Vector{}", length as u32);

    let expanded = quote! {
        pub struct #title {
            #fields
        }

        impl #title {
            pub fn new(#args) -> Self {
                Self {
                    #initalizers
                }
            }
        }

        impl Vector for #title {
            fn dot(&self, other: &Self) -> f64 {
                #dot_product_statement
            }

            fn magnitude(&self) -> f64 {
                #magnitude_statement
            }

            fn normalize(&self) -> Self {
                #normalize_func
            }
        }
    };

    TokenStream::from(expanded)
}
